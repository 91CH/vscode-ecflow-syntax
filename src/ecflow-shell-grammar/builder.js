#!/usr/bin/env node
/**
Build the ecflow-shell.tmLanguage.json syntax file.

The final grammar file is creating by composing the shell grammar with
extra definitions implementing ecFlow syntax extensions. The shell
grammar file is modified by this script to allow some ecFlow syntax to
be nested inside shell syntax. This is done procedurally to avoid
maintaining a modified copy of the shell grammar file.
*/

const fs = require("fs");
const path = require("path");

const source_dir = 'src/ecflow-shell-grammar';
const ecflow_grammar_extensions = `${source_dir}/ecflow-extensions.tmLanguage.json`;
const shell_unix_bash_grammar = `${source_dir}/shell-unix-bash.tmLanguage.json`;
const target_file = 'syntaxes/ecflow-shell.tmLanguage.json';

/**
 * Read, transform, and merge the components of the ecflow-shell grammar.
 */
function main() {
  let shell_json = read_syntax(shell_unix_bash_grammar);
  console.log(`loaded shell grammar from ${shell_unix_bash_grammar}`);

  let ecflow_json = read_syntax(ecflow_grammar_extensions);
  console.log(`loaded additional ecFlow grammar definitions from ${ecflow_grammar_extensions}`);
  
  let final_grammar_json = JSON.stringify(
    merge_grammars(
      transform_ecflow_json(ecflow_json),
      transform_shell_json(shell_json)
    ),
    null,
    4
  )

  fs.writeFileSync(target_file, final_grammar_json);

  console.log(`wrote merged grammar in ${target_file}\n`);
}

/**
 * Read a syntax grammar definition file
 */
function read_syntax(filename) {
  return JSON.parse(fs.readFileSync(filename));
}

/**
 * Apply modifications to the ecFlow grammar extras
 */
function transform_ecflow_json(json) {
  json.information_for_contributors = [
    `This file is automatically generated by combining the ecFlow-specific language`,
    `extensions defined in ${ecflow_grammar_extensions}`,
    `with everything normally defined for shell scripts in ${shell_unix_bash_grammar}`,
  ];

  return json;
}

/**
 * Apply modifications to the shell grammar
 */
function transform_shell_json(json) {
  // Inject ecflow variable patterns in to strings (both single and double quoted)
  ["string.quoted.single.shell", "string.quoted.double.shell"].forEach(
    (pattern_name) => {
      let pattern = find_pattern_by_name(
        json.repository.string.patterns,
        pattern_name
      );
      if ("patterns" in pattern) {
        pattern.patterns.push({
          include: "#ecflow-variable",
        });
      } else {
        pattern.patterns = [
          {
            include: "#ecflow-variable",
          },
        ];
      }
    }
  );

  // Inject ecFlow variable patterns in to shell variable parameter expansions.
  // The pattern match for such patterns needs to be amended because % and %%
  // are both valid shell parameter expansions (for stripping a suffix), so we
  // edit the match to require that these expansions only match when not
  // preceded by `:-` or `:=`. This provides a workable solution for the most
  // common use cases.
  let bracket_pattern = find_pattern_by_name(
    json.repository.variable.patterns,
    "variable.other.bracket.shell"
  );

  let expansion_pattern = find_pattern_by_name(
    bracket_pattern.patterns,
    "keyword.operator.expansion.shell"
  );

  expansion_pattern.match = expansion_pattern.match.replace(
    "%{1,2}",
    "(?<!:[-=])%{1,2}"
  );
  bracket_pattern.patterns.push({
    include: "#ecflow-variable",
  });

  // Modify the language used for SHELL and default heredocs, we want to use
  // ecflow-shell as the language in both
  [
    "string.unquoted.heredoc.no-indent.shell.shell",
    "string.unquoted.heredoc.shell.shell",
    "string.unquoted.heredoc.no-indent.shell",
    "string.unquoted.heredoc.shell",
  ].forEach((pattern_name) => {
    let pattern = find_pattern_by_name(
      json.repository.heredoc.patterns,
      pattern_name
    );
    pattern.patterns = [{ include: "source.ecflow-shell" }];
  });

  return json;
}

/**
 * Merge two grammar definitions in to the first, returning the result
 */
function merge_grammars(base_grammar, appended_grammar) {
  base_grammar.patterns = base_grammar.patterns.concat(appended_grammar.patterns);
  base_grammar.repository = Object.assign(base_grammar.repository, appended_grammar.repository);
  return base_grammar;
}

/**
 * Find a pattern object by its 'name' key
 */
function find_pattern_by_name(patterns, name) {
  for (var pattern of patterns) {
    if (pattern.name == name) {
      return pattern;
    }
  }
}

main();
